%{ Focusing for polarized logic. }%

%{ == Syntax == }%

pol: type. %name pol P.
⁺: pol.
⁻: pol.

%{ We define propositions in an environment with free atoms. }%
atom: pol -> type. %name atom Q q.
%block atom⁺: block {Q⁺: atom ⁺}.
%block atom⁻: block {Q⁻: atom ⁻}.

typ: pol -> type. %name typ A.
c: atom P -> typ P.
↓: typ ⁻ -> typ ⁺.
↑: typ ⁺ -> typ ⁻.
0: typ ⁺.
⊕: typ ⁺ -> typ ⁺ -> typ ⁺. %infix none 5 ⊕.
1: typ ⁺.
⊗: typ ⁺ -> typ ⁺ -> typ ⁺. %infix none 5 ⊗.
⊤: typ ⁻.
&: typ ⁻ -> typ ⁻ -> typ ⁻. %infix none 5 &.
⊸: typ ⁺ -> typ ⁻ -> typ ⁻. %infix none 5 ⊸.

%{ Right-stable propositions are ones that are either atomic or shifted. }%
stable: typ ⁻ -> type. %name stable St.
aQ: stable (c Q).
a↑: stable (↑ A⁺).

%{ An inversion or focus context Δ is a list of positive propositions. }%
pos: type. %name pos _Δ.
·: pos.
,: typ ⁺ -> pos -> pos. %infix right 3 ,.


%{ === Syntax metric === }%

met: typ ⁻ -> type. %name met S.
met⁻: typ ⁻ -> type. %name met⁻ S.
met⁺: typ ⁺ -> type. %name met⁺ S.
metΔ: pos -> type. %name metΔ S.

m: met⁻ A⁻ -> met A⁻.

mc⁻: met⁻ (c Q).
m↑: met⁺ A⁺ -> met⁻ (↑ A⁺).
m⊤: met⁻ ⊤.
m&: met⁻ A⁻ -> met⁻ B⁻ -> met⁻ (A⁻ & B⁻).
m⊸: met⁺ A⁺ -> met⁻ B⁻ -> met⁻ (A⁺ ⊸ B⁻).

mΔ: metΔ (A⁺ , ·) -> met⁺ A⁺.

m·: metΔ ·.
mc⁺: metΔ _Δ -> metΔ (c Q , _Δ).
m↓: met A⁻ -> metΔ _Δ -> metΔ (↓ A⁻ , _Δ).
m0: metΔ (0 , _Δ).
m⊕: metΔ (A⁺ , _Δ) -> metΔ (B⁺ , _Δ) -> metΔ (A⁺ ⊕ B⁺ , _Δ).
m1: metΔ _Δ -> metΔ (1 , _Δ).
m⊗: metΔ (A⁺ , B⁺ , _Δ) -> metΔ (A⁺ ⊗ B⁺ , _Δ).


%{ == Sequent calculus == }%

%{ The judgments of the focused language (or, alternatively, syntax of 
intrinsically typed spine form judgments) }%
hyp⁻: typ ⁻ -> type. %name hyp⁻ X⁻ x⁻.
hyp⁺: atom ⁺ -> type. %name hyp⁺ X⁺ x⁺.
%block x⁺ : some {Q⁺ : atom ⁺} block {x⁺ : hyp⁺ Q⁺}.
%block x⁻ : some {A⁻ : typ ⁻}  block {x⁻ : hyp⁻ A⁻}.

conc: typ ⁻ -> type. %name conc N.
linv:  pos -> typ ⁻ -> type. %name linv Ni.
lfoc: typ ⁻ -> typ ⁻ -> type. %name lfoc Sp.
rfoc: pos -> type. %name rfoc V.

%{ `N ::= x⁻ • Sp ∣ σ ∣ <> ∣ <N₁,N₂> ∣ λNi' }%
foc: hyp⁻ A⁻ -> stable C⁻ -> lfoc A⁻ C⁻ -> conc C⁻.
↑R: rfoc (A⁺ , ·) -> conc (↑ A⁺).
⊤R: conc ⊤.
&R: conc A⁻ -> conc B⁻ -> conc (A⁻ & B⁻).
⊸R: linv (A⁺ , ·) B⁻ -> conc (A⁺ ⊸ B⁻).

%{ `σ ::= · ∣ x⁺,σ ∣ N,σ ∣ inl σ ∣ inr σ ∣ <>,σ ∣ ⊗σ' }%
·R: rfoc ·.
cR: hyp⁺ Q⁺ -> rfoc _Δ -> rfoc (c Q⁺ , _Δ).
↓R: conc A⁻ -> rfoc _Δ -> rfoc (↓ A⁻ , _Δ).
⊕R₁: rfoc (A⁺ , _Δ) -> rfoc (A⁺ ⊕ B⁺ , _Δ).
⊕R₂: rfoc (B⁺ , _Δ) -> rfoc (A⁺ ⊕ B⁺ , _Δ).
1R: rfoc _Δ -> rfoc (1 , _Δ).
⊗R: rfoc (A⁺ , B⁺ , _Δ) -> rfoc (A⁺ ⊗ B⁺ , _Δ).

%{ `Sp ::= nil ∣ cont Ni ∣ π₁ Sp ∣ π₂ Sp ∣ σ;Sp' }%
init: lfoc (c Q⁻) (c Q⁻).
↑L: linv (A⁺ , ·) C⁻ -> lfoc (↑ A⁺) C⁻.
&L₁: lfoc A⁻ C⁻ -> lfoc (A⁻ & B⁻) C⁻.
&L₂: lfoc B⁻ C⁻ -> lfoc (A⁻ & B⁻) C⁻.
⊸L: rfoc (A⁺ , ·) -> lfoc B⁻ C⁻ -> lfoc (A⁺ ⊸ B⁻) C⁻.

%{ `Ni ::= N ∣ x⁺.p ∣ x⁻.Ni ∣ abort ∣ [Ni₁,Ni₂] ∣ <>.Ni ∣ ⊗Ni' }%
·L: conc C⁻ -> linv · C⁻.
cL: (hyp⁺ Q⁺ -> linv _Δ C⁻) -> linv (c Q⁺ , _Δ) C⁻.
↓L: (hyp⁻ A⁻ -> linv _Δ C⁻) -> linv (↓ A⁻ , _Δ) C⁻.
0L: linv (0 , _Δ) C⁻.
⊕L: linv (A⁺ , _Δ) C⁻ -> linv (B⁺ , _Δ) C⁻ -> linv (A⁺ ⊕ B⁺ , _Δ) C⁻.
1L: linv _Δ C⁻ -> linv (1 , _Δ) C⁻.
⊗L: linv (A⁺ , B⁺ , _Δ) C⁻ -> linv (A⁺ ⊗ B⁺ , _Δ) C⁻.


%{ == Cut admissibility == }%

%{ Cut admissibility has a lot of mutually inductive theorems, but no more
than is absolutely necessary given the four syntactic classes we're dealing
with. Furthermore, the different theorems we use neatly separate the 
informal division of cases that we are used to when dealing with cut 
admissibility theorems.

The "principal" substitutions capture the principal cuts: 
* `M • Sp' - negative cut formula, and
* `σ • Ni' - positive cut formula.
In this presentation, we have generalized what it means to be a "positive
cut formula": instead of a single formula `A⁺', it is a context of positive
formulas `Δ'. Each inductive call within this group decreases the "size" of the
cut formula by a multiset ordering where the positive conjunction `⊗' counts
for two and the conjunction of positive contexts `,' counts for one. To make
Twelf happy, we turn this into a structural metric. }%

subst⁻: met⁻ A⁻ -> conc A⁻ -> lfoc A⁻ C⁻ -> stable C⁻ 
  -> conc C⁻ -> type.
subst⁺: metΔ _Δ -> rfoc _Δ -> linv _Δ C⁻ 
  -> conc C⁻ -> type.

%mode subst⁻ +M +D +E +S -F.
%mode subst⁺ +M +D +E -F.

%{ The "rightist" substitutions captures the right commutative cuts:
* `[M/x]N' - right rules for negative connectives, 
* `[M/x]σ' - right rules for positive connectives, 
* `[M/x]Sp' - left rules for negative connectives, and
* `[M/x]Ni' - left rules for positive connectives. 
Each inductive call within this group decreases the size of the formula that 
we are substituting into. }%

cutN:   met A⁻ -> conc A⁻ -> (hyp⁻ A⁻ -> conc C⁻) 
  -> conc C⁻ -> type.
cutV:   met A⁻ -> conc A⁻ -> (hyp⁻ A⁻ -> rfoc _Δ) 
  -> rfoc _Δ -> type.
cutSp:  met A⁻ -> conc A⁻ -> (hyp⁻ A⁻ -> lfoc B⁻ C⁻) 
  -> lfoc B⁻ C⁻ -> type.
cutNi:  met A⁻ -> conc A⁻ -> (hyp⁻ A⁻ -> linv _Δ C⁻) 
  -> linv _Δ C⁻ -> type.

%mode cutN  +M +D +E -F.
%mode cutV  +M +D +E -F.
%mode cutSp +M +D +E -F.
%mode cutNi +M +D +E -F.

%{ The "leftist" substitutions capture the left commutative cuts, and 
are only called when we bottom out of principal substitutions:
* `〈Sp〉Ni' - left rules for negative connectives
* `〈Mi⟩ Ni' - left rules for positive connectives.
Each inductive call within this group decreases the size of the formula that
we are substituting in, hence "leftist." }%

left⁻:  met⁺ A⁺ -> lfoc B⁻ (↑ A⁺) -> linv (A⁺ , ·) C⁻ -> stable C⁻ 
  -> lfoc B⁻ C⁻ -> type.
left⁺:  met⁺ A⁺ -> linv _Δ (↑ A⁺) -> linv (A⁺ , ·) C⁻ -> stable C⁻ 
  -> linv _Δ C⁻ -> type.

%mode left⁻ +M +D +E +S -F.
%mode left⁺ +M +D +E +S -F.

%{ === Principal substitution/cuts === }%

-: subst⁻ mc⁻ (foc X aQ Sp) init _ (foc X aQ Sp).

-: subst⁻ (m↑ Mt) (foc X a↑ Sp) (↑L N) St (foc X St Sp2)
  <- left⁻ Mt Sp N St (Sp2: lfoc B⁻ C⁻).

-: subst⁻ (m↑ (mΔ Mt)) (↑R V) (↑L N) _ N2
  <- subst⁺ Mt V N (N2: conc C⁻).

-: subst⁻ (m& Mt₁ Mt₂) (&R N₁ N₂) (&L₁ Sp) St N2
  <- subst⁻ Mt₁ N₁ Sp St (N2: conc C⁻).

-: subst⁻ (m& Mt₁ Mt₂) (&R N₁ N₂) (&L₂ Sp) St N2
  <- subst⁻ Mt₂ N₂ Sp St (N2: conc C⁻).

-: subst⁻ (m⊸ (mΔ Mt₁) Mt₂) (⊸R N) (⊸L V Sp) St N3 
  <- subst⁺ Mt₁ V N (N2: conc B⁻)
  <- subst⁻ Mt₂ N2 Sp St (N3: conc C⁻).

-: subst⁺ m· ·R (·L N) N.

-: subst⁺ (mc⁺ Mt) (cR X V) (cL ([x] N x)) (N2 X)
  <- ({x: hyp⁺ Q⁺} subst⁺ Mt V (N x) (N2 x: conc C⁻)).

-: subst⁺ (m↓ Mt₁ Mt₂) (↓R M V) (↓L N) N3
  <- cutNi Mt₁ M N (N2: linv _Δ C⁻)
  <- subst⁺ Mt₂ V N2 (N3: conc C⁻).

-: subst⁺ (m⊕ Mt₁ Mt₂) (⊕R₁ V) (⊕L N₁ N₂) N2
  <- subst⁺ Mt₁ V N₁ (N2: conc C⁻).

-: subst⁺ (m⊕ Mt₁ Mt₂) (⊕R₂ V) (⊕L N₁ N₂) N2
  <- subst⁺ Mt₂ V N₂ (N2: conc C⁻).

-: subst⁺ (m1 Mt) (1R V) (1L N) N2
  <- subst⁺ Mt V N (N2: conc C⁻).

-: subst⁺ (m⊗ Mt) (⊗R V) (⊗L N) N2
  <- subst⁺ Mt V N (N2: conc C⁻).

%{ === Rightist substitution (right commutative cuts) === }%

-: cutN (m Mt) M ([x] foc x St (Sp x)) N2
  <- cutSp (m Mt) M ([x] Sp x) (Sp2: lfoc A⁻ C⁻)
  <- subst⁻ Mt M Sp2 St (N2: conc C⁻).

-: cutN Mt M ([x] foc X St (Sp x)) (foc X St Sp2)
  <- cutSp Mt M ([x] Sp x) (Sp2: lfoc B⁻ C⁻).

-: cutN Mt M ([x] ↑R (V x)) (↑R V2)
  <- cutV Mt M ([x] V x) (V2: rfoc (C⁺ , ·)).

-: cutN Mt M ([x] ⊤R) ⊤R.

-: cutN Mt M ([x] &R (N₁ x) (N₂ x)) (&R N₁2 N₂2)
  <- cutN Mt M ([x] N₁ x) (N₁2: conc C₁⁻)
  <- cutN Mt M ([x] N₂ x) (N₂2: conc C₂⁻).

-: cutN Mt M ([x] ⊸R (N x)) (⊸R N2)
  <- cutNi Mt M ([x] N x) (N2: linv (C₁⁺ , ·) C₂⁻).

-: cutV Mt M ([x] ·R) ·R.

-: cutV Mt M ([x] cR X (V x)) (cR X V2)
  <- cutV Mt M ([x] V x) (V2: rfoc _Δ).

-: cutV Mt M ([x] ↓R (N x) (V x)) (↓R N2 V2)
  <- cutN Mt M ([x] N x) (N2: conc C⁻)
  <- cutV Mt M ([x] V x) (V2: rfoc _Δ).

-: cutV Mt M ([x] ⊕R₁ (V x)) (⊕R₁ V2)
  <- cutV Mt M ([x] V x) (V2: rfoc (C₁⁺ , _Δ)).

-: cutV Mt M ([x] ⊕R₂ (V x)) (⊕R₂ V2)
  <- cutV Mt M ([x] V x) (V2: rfoc (C₂⁺ , _Δ)).

-: cutV Mt M ([x] 1R (V x)) (1R V2)
  <- cutV Mt M ([x] V x) (V2: rfoc _Δ).

-: cutV Mt M ([x] ⊗R (V x)) (⊗R V2)
  <- cutV Mt M ([x] V x) (V2: rfoc (C₁⁺ , C₂⁺ , _Δ)).

-: cutSp Mt M ([x] init) init.

-: cutSp Mt M ([x] ↑L (N x)) (↑L N2)
  <- cutNi Mt M ([x] N x) (N2: linv (B⁺ , ·) C⁻).

-: cutSp Mt M ([x] &L₁ (Sp x)) (&L₁ Sp2)
  <- cutSp Mt M ([x] Sp x) (Sp2: lfoc B₁⁻ C⁻).

-: cutSp Mt M ([x] &L₂ (Sp x)) (&L₂ Sp2)
  <- cutSp Mt M ([x] Sp x) (Sp2: lfoc B₂⁻ C⁻).

-: cutSp Mt M ([x] ⊸L (V x) (Sp x)) (⊸L V2 Sp2)
  <- cutV Mt M ([x] V x) (V2: rfoc (B₁⁺ , ·))
  <- cutSp Mt M ([x] Sp x) (Sp2: lfoc B₂⁻ C⁻).

-: cutNi Mt M ([x] ·L (N x)) (·L N2)
  <- cutN Mt M ([x] N x) (N2: conc C⁻).

-: cutNi Mt M ([x] cL [y] N x y) (cL [y] N2 y)
  <- ({y: hyp⁺ Q⁺} cutNi Mt M ([x] N x y) (N2 y: linv _Δ C⁻)).

-: cutNi Mt M ([x] ↓L [y] N x y) (↓L [y] N2 y)
  <- ({y: hyp⁻ B⁻} cutNi Mt M ([x] N x y) (N2 y: linv _Δ C⁻)).

-: cutNi Mt M ([x] 0L) 0L.

-: cutNi Mt M ([x] ⊕L (N₁ x) (N₂ x)) (⊕L N₁2 N₂2)
  <- cutNi Mt M ([x] N₁ x) (N₁2: linv (B₁ , _Δ) C⁻)
  <- cutNi Mt M ([x] N₂ x) (N₂2: linv (B₂ , _Δ) C⁻).

-: cutNi Mt M ([x] 1L (N x)) (1L N2)
  <- cutNi Mt M ([x] N x) (N2: linv _Δ C⁻).

-: cutNi Mt M ([x] ⊗L (N x)) (⊗L N2)
  <- cutNi Mt M ([x] N x) (N2: linv (A⁺ , B⁺ , _Δ) C⁻).

%{ === Leftist substitution (left commutative cuts) === }%

-: left⁻ Mt (↑L M) N St (↑L N2)
  <- left⁺ Mt M N St (N2: linv (B⁺ , ·) C⁻).

-: left⁻ Mt (&L₁ Sp) N St (&L₁ Sp2)
  <- left⁻ Mt Sp N St (Sp2: lfoc B₁⁻ C⁻).

-: left⁻ Mt (&L₂ Sp) N St (&L₂ Sp2)
  <- left⁻ Mt Sp N St (Sp2: lfoc B₂⁻ C⁻).

-: left⁻ Mt (⊸L V Sp) N St (⊸L V Sp2)
  <- left⁻ Mt Sp N St (Sp2: lfoc B₂⁻ C⁻).

-: left⁺ Mt (·L (foc X _ Sp)) N St (·L (foc X St Sp2))
  <- left⁻ Mt Sp N St (Sp2: lfoc B⁻ C⁻).

-: left⁺ (mΔ Mt) (·L (↑R V)) N St (·L N2)
  <- subst⁺ Mt V N (N2: conc C⁻).

-: left⁺ Mt (cL [y] M y) N St (cL [y] N2 y)
  <- ({y: hyp⁺ Q⁺} left⁺ Mt (M y) N St (N2 y: linv _Δ C⁻)).

-: left⁺ Mt (↓L [y] M y) N St (↓L [y] N2 y)
  <- ({y: hyp⁻ B⁻} left⁺ Mt (M y) N St (N2 y: linv _Δ C⁻)).

-: left⁺ Mt 0L N St 0L.

-: left⁺ Mt (⊕L M₁ M₂) N St (⊕L N₁2 N₂2)
  <- left⁺ Mt M₁ N St (N₁2: linv (B₁⁺ , _Δ) C⁻)
  <- left⁺ Mt M₂ N St (N₂2: linv (B₂⁺ , _Δ) C⁻).

-: left⁺ Mt (1L M) N St (1L N2)
  <- left⁺ Mt M N St (N2: linv _Δ C⁻).

-: left⁺ Mt (⊗L M) N St (⊗L N2)
  <- left⁺ Mt M N St (N2: linv (A⁺ , B⁺ , _Δ) C⁻).

%{ === Wrap-up === }%

%worlds (atom⁺ | atom⁻ | x⁺ | x⁻)
  (subst⁻ _ _ _ _ _)
  (subst⁺ _ _ _ _)
  (cutN _ _ _ _)
  (cutV _ _ _ _)
  (cutSp _ _ _ _)
  (cutNi _ _ _ _)
  (left⁻ _ _ _ _ _)
  (left⁺ _ _ _ _ _).

%total 
  {(Mt1 Mt2 Mt3 Mt4 Mt5 Mt6 Mt7 Mt8) 
    [(MN MV MSp MNi MP VP SpL MiL) 
     (N V Sp Ni SpP NiP NiL⁻ NiL⁺)]}
  (subst⁻ Mt5 MP  SpP _ _)
  (subst⁺ Mt6 VP  NiP _)
  (cutN   Mt1 MN  N _)
  (cutV   Mt2 MV  V _)
  (cutSp  Mt3 MSp Sp _)
  (cutNi  Mt4 MNi Ni _)
  (left⁻  Mt7 SpL NiL⁻ _ _)
  (left⁺  Mt8 MiL NiL⁺ _ _).


%{ == Expansion == }%

eta⁻: met⁻ A⁻ 
  -> ({γ: typ ⁻} stable γ -> lfoc A⁻ γ -> conc γ) 
  -> conc A⁻ 
  -> type.

eta⁺: metΔ _Δ 
  -> (rfoc _Δ -> conc C⁻)
  -> linv _Δ C⁻ 
  -> type.

%mode eta⁻ +Mt +A -B.
%mode eta⁺ +Mt +A -B.

-: eta⁻ mc⁻ ([γ][st][sp: lfoc (c Q⁻) γ] N γ st sp) (N (c Q⁻) aQ init). 

-: eta⁻
  (m↑ (mΔ Mt)) ([γ][st][sp: lfoc (↑ A⁺) γ] N γ st sp) 
  (N (↑ A⁺) a↑ (↑L N2))
  <- eta⁺ Mt ([v: rfoc (A⁺ , ·)] ↑R v) (N2: linv (A⁺ , ·) (↑ A⁺)).

-: eta⁻ m⊤ ([γ][st][sp: lfoc ⊤ γ] N γ st sp) ⊤R.

-: eta⁻ (m& Mt₁ Mt₂) ([γ][st][sp: lfoc (A⁻ & B⁻) γ] N γ st sp) (&R N₁ N₂)
  <- eta⁻ Mt₁ ([γ][st][sp: lfoc A⁻ γ] N γ st (&L₁ sp)) N₁
  <- eta⁻ Mt₂ ([γ][st][sp: lfoc B⁻ γ] N γ st (&L₂ sp)) N₂.  

-: eta⁻ (m⊸ (mΔ Mt₁) Mt₂) ([γ][st][sp: lfoc (A⁺ ⊸ B⁻) γ] N γ st sp) (⊸R Ni2)
  <- ({σ: rfoc (A⁺ , ·)}
       eta⁻ Mt₂ ([γ][st][sp: lfoc B⁻ γ] N γ st (⊸L σ sp)) (N2 σ))
  <- eta⁺ Mt₁ ([σ: rfoc (A⁺ , ·)] N2 σ) Ni2.

-: eta⁺ m· ([σ: rfoc ·] N σ) (·L (N ·R)).

-: eta⁺ (mc⁺ Mt) ([v: rfoc (c Q⁺ , _Δ)] N v) (cL [x] N2 x)
  <- ({x} eta⁺ Mt ([σ: rfoc _Δ] N (cR x σ)) (N2 x: linv _Δ C⁻)).

-: eta⁺ (m↓ (m Mt₁) Mt₂) ([v: rfoc (↓ A⁻ , _Δ)] N v) (↓L [x: hyp⁻ A⁻] Ni2 x)
  <- ({x: hyp⁻ A⁻}
       eta⁻ Mt₁ ([γ][st][sp: lfoc A⁻ γ] foc x st sp)
       (N2 x: conc A⁻))
  <- ({x: hyp⁻ A⁻}
       eta⁺ Mt₂ ([v: rfoc _Δ] N (↓R (N2 x) v)) 
       (Ni2 x: linv _Δ C⁻)).

-: eta⁺ m0 ([v: rfoc (0 , _Δ)] N v) 0L.

-: eta⁺ (m⊕ Mt₁ Mt₂) ([v: rfoc (A⁺ ⊕ B⁺ , _Δ)] N v) (⊕L N₁2 N₂2)
  <- eta⁺ Mt₁ ([v: rfoc (A⁺ , _Δ)] N (⊕R₁ v)) (N₁2: linv (A⁺ , _Δ) C⁻)
  <- eta⁺ Mt₂ ([v: rfoc (B⁺ , _Δ)] N (⊕R₂ v)) (N₂2: linv (B⁺ , _Δ) C⁻).

-: eta⁺ (m1 Mt) ([v: rfoc (1 , _Δ)] N v) (1L N2)
  <- eta⁺ Mt ([v: rfoc _Δ] N (1R v)) (N2: linv _Δ C⁻).

-: eta⁺ (m⊗ Mt) ([v: rfoc (A⁺ ⊗ B⁺ , _Δ)] N v) (⊗L N2)
  <- eta⁺ Mt ([v: rfoc (A⁺ , B⁺ , _Δ)] N (⊗R v)) (N2: linv (A⁺ , B⁺ , _Δ) C⁻).

%block rfocs: some {_Δ: pos} block {v: rfoc _Δ}.
%worlds (atom⁺ | atom⁻ | x⁺ | x⁻ | rfocs)
  (eta⁻ _ _ _)
  (eta⁺ _ _ _).
%total (Mt1 Mt2)
  (eta⁻ Mt1 _ _)
  (eta⁺ Mt2 _ _).