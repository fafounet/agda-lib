%{ Focusing for polarized logic. This proof has been de-unicoded by a sed 
[https://github.com/robsimmons/agda-lib/blob/lambdatown/sedforwiki script],
the original is
[https://github.com/robsimmons/agda-lib/blob/lambdatown/Polar2.elf here]. }%

%{ == Syntax == }%

pol: type. %name pol P.
⁺: pol.
⁻: pol.
⁼: pol. 

%{ We define propositions in an environment with free atoms. }%
atom: pol -> type. %name atom Q q.
%block atom⁺: block {Q⁺: atom ⁺}.
%block atom⁻: block {Q⁻: atom ⁻}.

typ: pol -> type. %name typ A.
c: atom P -> typ P.
↓: typ ⁻ -> typ ⁺.
↑: typ ⁺ -> typ ⁻.
0: typ ⁺.
⊕: typ ⁺ -> typ ⁺ -> typ ⁺. %infix none 5 ⊕.
1: typ ⁺.
⊗: typ ⁺ -> typ ⁺ -> typ ⁺. %infix none 5 ⊗.
⊤: typ ⁻.
&: typ ⁻ -> typ ⁻ -> typ ⁻. %infix none 5 &.
⊸: typ ⁺ -> typ ⁻ -> typ ⁻. %infix none 5 ⊸.

%{ Right-stable propositions are ones that are either atomic or shifted. }%
stable: typ ⁻ -> type. %name stable St.
aQ: stable (c Q).
a↑: stable (↑ A⁺).

%{ An inversion or focus context Δ is a list of positive propositions. }%
pos: type. %name pos _Δ.
·: pos.
,: typ ⁺ -> pos -> pos. %infix right 3 ,.

%{ === Term metric === }%

%{ Twelf's termination ordering isn't quite right for what we need. Ordering
of rules is given lowest priority and we need to be able to give it 
second-highest priority, because we make a call to the subst⁻ function on
larger subterms but at the same type. }%

met: {P: pol} typ Q -> type. %name met Mt.

me: met ⁻ A⁻ -> met ⁼ (A⁻: typ ⁻).

mc: met P (c Q: typ P).
m↓: met ⁼ A⁻ -> met ⁺ (↓ A⁻).
m↑: met ⁺ A⁺ -> met ⁻ (↑ A⁺).
m0: met ⁺ 0.
m⊕: met ⁺ A⁺ -> met ⁺ B⁺ -> met ⁺ (A⁺ ⊕ B⁺).
m1: met ⁺ 1.
m⊗: met ⁺ A⁺ -> met ⁺ B⁺ -> met ⁺ (A⁺ ⊗ B⁺).
m⊤: met ⁻ ⊤.
m&: met ⁻ A⁻ -> met ⁻ B⁻ -> met ⁻ (A⁻ & B⁻).
m⊸: met ⁺ A⁺ -> met ⁻ B⁻ -> met ⁻ (A⁺ ⊸ B⁻).

inmet: {A: typ P} met P A -> type.
%mode inmet +A -Mt.

-: inmet (c Q) mc.
-: inmet (↓ A⁻) (m↓ (me Mt)) <- inmet A⁻ Mt.
-: inmet (↑ A⁺) (m↑ Mt) <- inmet A⁺ Mt.
-: inmet 0 m0.
-: inmet (A⁺ ⊕ B⁺) (m⊕ Mt₁ Mt₂) <- inmet A⁺ Mt₁ <- inmet B⁺ Mt₂.
-: inmet 1 m1.
-: inmet (A⁺ ⊗ B⁺) (m⊗ Mt₁ Mt₂) <- inmet A⁺ Mt₁ <- inmet B⁺ Mt₂.
-: inmet ⊤ m⊤.
-: inmet (A⁻ & B⁻) (m& Mt₁ Mt₂) <- inmet A⁻ Mt₁ <- inmet B⁻ Mt₂.
-: inmet (A⁺ ⊸ B⁻) (m⊸ Mt₁ Mt₂) <- inmet A⁺ Mt₁ <- inmet B⁻ Mt₂.

%worlds (atom⁺ | atom⁻) (inmet _ _).
%total A (inmet A _).

%{ == Sequent calculus == }%

%{ The judgments of the focused language (or, alternatively, syntax of 
intrinsically typed spine form judgments) }%
hyp⁺: atom ⁺ -> type. %name hyp⁺ X⁺ x⁺.
hyp⁻: typ ⁻ -> type. %name hyp⁻ X⁻ x⁻.
%block x⁺ : some {Q⁺: atom ⁺} block {x⁺: hyp⁺ Q⁺}.
%block x⁻ : some {A⁻: typ ⁻}  block {x⁻: hyp⁻ A⁻}.
%block vars = (atom⁺ | atom⁻ | x⁺ | x⁻).

rfoc: typ ⁺ -> type. %name rfoc V.
conc: pos -> typ ⁻ -> type. %name conc N.
lfoc: typ ⁻ -> typ ⁻ -> type. %name lfoc Sp.
%block v : some {A⁺: typ ⁺} block {v: rfoc A⁺}.
%block sp : some {A⁻: typ ⁻} block {γ}{sp: lfoc A⁻ (c γ)}.

%{ ``V ::= x⁺ ∣ N ∣ inl V ∣ inr V ∣ <> ∣ <V₁,V₂>'' }%
cR: hyp⁺ Q⁺ -> rfoc (c Q⁺).
↓R: conc · A⁻ -> rfoc (↓ A⁻).
⊕R₁: rfoc A⁺ -> rfoc (A⁺ ⊕ B⁺).
⊕R₂: rfoc B⁺ -> rfoc (A⁺ ⊕ B⁺).
1R: rfoc 1.
⊗R: rfoc A⁺ -> rfoc B⁺ -> rfoc (A⁺ ⊗ B⁺).

%{ ``N ::= x⁻ • Sp ∣ σ ∣ <> ∣ <N₁,N₂> ∣ λNi'' }%
foc: hyp⁻ A⁻ -> stable C⁻ -> lfoc A⁻ C⁻ -> conc · C⁻.
↑R: rfoc A⁺ -> conc · (↑ A⁺).
⊤R: conc · ⊤.
&R: conc · A⁻ -> conc · B⁻ -> conc · (A⁻ & B⁻).
⊸R: conc (A⁺ , ·) B⁻ -> conc · (A⁺ ⊸ B⁻).

%{ ``Ni ::= N ∣ x⁺.p ∣ x⁻.Ni ∣ abort ∣ [Ni₁,Ni₂] ∣ <>.Ni ∣ ⊗Ni'' }%
cL: (hyp⁺ Q⁺ -> conc _Δ C⁻) -> conc (c Q⁺ , _Δ) C⁻.
↓L: (hyp⁻ A⁻ -> conc _Δ C⁻) -> conc (↓ A⁻ , _Δ) C⁻.
0L: conc (0 , _Δ) C⁻.
⊕L: conc (A⁺ , _Δ) C⁻ -> conc (B⁺ , _Δ) C⁻ -> conc (A⁺ ⊕ B⁺ , _Δ) C⁻.
1L: conc _Δ C⁻ -> conc (1 , _Δ) C⁻.
⊗L: conc (A⁺ , B⁺ , _Δ) C⁻ -> conc (A⁺ ⊗ B⁺ , _Δ) C⁻.

%{ ``Sp ::= nil ∣ cont Ni ∣ π₁ Sp ∣ π₂ Sp ∣ V;Sp'' }%
nil: lfoc (c Q⁻) (c Q⁻).
↑L: conc (A⁺ , ·) C⁻ -> lfoc (↑ A⁺) C⁻.
&L₁: lfoc A⁻ C⁻ -> lfoc (A⁻ & B⁻) C⁻.
&L₂: lfoc B⁻ C⁻ -> lfoc (A⁻ & B⁻) C⁻.
⊸L: rfoc A⁺ -> lfoc B⁻ C⁻ -> lfoc (A⁺ ⊸ B⁻) C⁻.


%{ == Cut admissibility == }%

%{ Cut admissibility has a lot of mutually inductive theorems, but no more
than is absolutely necessary given the syntactic classes we're dealing
with. Furthermore, the different theorems we use neatly sort out the 
informal division of cases that we are used to dealing with when proving
cut admissibility theorems.

The "principal" substitutions capture the principal cuts: 
* ``V • Ni'' - positive cut formula, and
* ``M • Sp'' - negative cut formula.
In this presentation, we have generalized what it means to be a "positive
cut formula": instead of a single formula ``A⁺'', it is a context of positive
formulas ``Δ''. Each inductive call within this group decreases the "size" of 
the cut formula by a multiset ordering where the positive conjunction ``⊗'' 
counts for two and the conjunction of positive contexts ``,'' counts for one. 
To make Twelf happy, we turn this into a structural metric. }%

subst⁺: met ⁺ A⁺ -> rfoc A⁺ -> conc (A⁺ , _Δ) C⁻ -> conc _Δ C⁻ -> type.
subst⁻: met ⁻ A⁻ -> conc · A⁻ -> lfoc A⁻ C⁻ -> stable C⁻ -> conc · C⁻ -> type.

%mode subst⁺ +A +V +N -N'.
%mode subst⁻ +A +N +Sp +St -N'.

%{ The "rightist" substitutions capture the right commutative cuts:
* ``[M/x]V'' - right rules for positive connectives,  
* ``[M/x]N'' - right rules for negative connectives, 
* ``[M/x]Ni'' - left rules for positive connectives,
* ``[M/x]Sp'' - left rules for negative connectives, and
Each inductive call within this group decreases the size of the formula that 
we are substituting into. }%

cutV:  met ⁼ A⁻ -> conc · A⁻ -> (hyp⁻ A⁻ -> rfoc C⁺) -> rfoc C⁺ -> type.
cutN:  met ⁼ A⁻ -> conc · A⁻ -> (hyp⁻ A⁻ -> conc _Δ C⁻) -> conc _Δ C⁻ -> type.
cutSp: met ⁼ A⁻ -> conc · A⁻ -> (hyp⁻ A⁻ -> lfoc B⁻ C⁻) -> lfoc B⁻ C⁻ ->  type.

%mode cutV  +A +M +V -N'.
%mode cutN  +A +M +N -N'.
%mode cutSp +A +M +Sp -N'.

%{ The "leftist" substitutions capture the left commutative cuts, and 
are only called when we bottom out of principal substitutions:
* ``{Sp}Ni'' - left rules for negative connectives
* ``{Mi}Ni'' - left rules for positive connectives.
Each inductive call within this group decreases the size of the formula that
we are substituting in, hence "leftist." }%

left⁻: met ⁺ A⁺ -> lfoc B⁻ (↑ A⁺) -> conc (A⁺ , ·) C⁻ -> stable C⁻
  -> lfoc B⁻ C⁻ -> type.
left⁺: met ⁺ A⁺ -> conc _Δ (↑ A⁺) -> conc (A⁺ , ·) C⁻ -> stable C⁻ 
  -> conc _Δ C⁻ -> type.

%mode left⁻ +A +Sp +Ni +Sp' -F.
%mode left⁺ +A +Mi +Ni +Ni' -F.

%{ === Principal substitution/cuts === }%

-: subst⁻ mc (foc X aQ Sp) nil _ (foc X aQ Sp).

-: subst⁻ (m↑ Mt) (foc X a↑ Sp) (↑L N) St (foc X St Sp')
  <- left⁻ Mt Sp N St (Sp': lfoc B⁻ C⁻).

-: subst⁻ (m↑ Mt) (↑R V) (↑L N) _ N'
  <- subst⁺ Mt V N (N': conc · C⁻).

-: subst⁻ (m& Mt₁ Mt₂) (&R N₁ N₂) (&L₁ Sp) St N'
  <- subst⁻ Mt₁ N₁ Sp St (N': conc · C⁻).

-: subst⁻ (m& Mt₁ Mt₂) (&R N₁ N₂) (&L₂ Sp) St N'
  <- subst⁻ Mt₂ N₂ Sp St (N': conc · C⁻).

-: subst⁻ (m⊸ Mt₁ Mt₂) (⊸R N) (⊸L V Sp) St N'
  <- subst⁺ Mt₁ V N (NB: conc · B⁻)
  <- subst⁻ Mt₂ NB Sp St (N': conc · C⁻).

-: subst⁺ mc (cR X) (cL ([x] N x)) (N X).

-: subst⁺ (m↓ Mt) (↓R M) (↓L N) N'
  <- cutN Mt M N (N': conc _Δ C⁻).

-: subst⁺ (m⊕ Mt₁ Mt₂) (⊕R₁ V) (⊕L N₁ N₂) N'
  <- subst⁺ Mt₁ V N₁ (N': conc _Δ C⁻).

-: subst⁺ (m⊕ Mt₁ Mt₂) (⊕R₂ V) (⊕L N₁ N₂) N'
  <- subst⁺ Mt₂ V N₂ (N': conc _Δ C⁻).

-: subst⁺ m1 1R (1L N) N.

-: subst⁺ (m⊗ Mt₁ Mt₂) (⊗R V₁ V₂) (⊗L N) N'
  <- subst⁺ Mt₁ V₁ N (NB: conc (B⁺ , _Δ) C⁻)
  <- subst⁺ Mt₂ V₂ NB (N': conc _Δ C⁻).

%{ === Rightist substitution (right commutative cuts) === }%

-: cutV Mt M ([x] cR X) (cR X).

-: cutV Mt M ([x] ↓R (N x)) (↓R N')
  <- cutN Mt M ([x] N x) (N': conc · C⁻).

-: cutV Mt M ([x] ⊕R₁ (V x)) (⊕R₁ V')
  <- cutV Mt M ([x] V x) (V': rfoc C₁⁺).

-: cutV Mt M ([x] ⊕R₂ (V x)) (⊕R₂ V')
  <- cutV Mt M ([x] V x) (V': rfoc C₂⁺).

-: cutV Mt M ([x] 1R) (1R).

-: cutV Mt M ([x] ⊗R (V₁ x) (V₂ x)) (⊗R V₁' V₂')
  <- cutV Mt M ([x] V₁ x) (V₁': rfoc C₁⁺)
  <- cutV Mt M ([x] V₂ x) (V₂': rfoc C₂⁺).

-: cutN (me Mt) M ([x] foc x St (Sp x)) N'
  <- cutSp (me Mt) M ([x] Sp x) (Sp': lfoc A⁻ C⁻)
  <- subst⁻ Mt M Sp' St (N': conc · C⁻).

-: cutN Mt M ([x] foc X St (Sp x)) (foc X St Sp')
  <- cutSp Mt M ([x] Sp x) (Sp': lfoc B⁻ C⁻).

-: cutN Mt M ([x] ↑R (V x)) (↑R V')
  <- cutV Mt M ([x] V x) (V': rfoc C⁺).

-: cutN Mt M ([x] ⊤R) ⊤R.

-: cutN Mt M ([x] &R (N₁ x) (N₂ x)) (&R N₁' N₂')
  <- cutN Mt M ([x] N₁ x) (N₁': conc · C₁⁻)
  <- cutN Mt M ([x] N₂ x) (N₂': conc · C₂⁻).

-: cutN Mt M ([x] ⊸R (N x)) (⊸R N')
  <- cutN Mt M ([x] N x) (N': conc (C₁⁺ , ·) C₂⁻).

-: cutN Mt M ([x] cL [y] N x y) (cL [y] N' y)
  <- ({y: hyp⁺ Q⁺} cutN Mt M ([x] N x y) (N' y: conc _Δ C⁻)).

-: cutN Mt M ([x] ↓L [y] N x y) (↓L [y] N' y)
  <- ({y: hyp⁻ B⁻} cutN Mt M ([x] N x y) (N' y: conc _Δ C⁻)).

-: cutN Mt M ([x] 0L) 0L.

-: cutN Mt M ([x] ⊕L (N₁ x) (N₂ x)) (⊕L N₁' N₂')
  <- cutN Mt M ([x] N₁ x) (N₁': conc (B₁ , _Δ) C⁻)
  <- cutN Mt M ([x] N₂ x) (N₂': conc (B₂ , _Δ) C⁻).

-: cutN Mt M ([x] 1L (N x)) (1L N')
  <- cutN Mt M ([x] N x) (N': conc _Δ C⁻).

-: cutN Mt M ([x] ⊗L (N x)) (⊗L N')
  <- cutN Mt M ([x] N x) (N': conc (A⁺ , B⁺ , _Δ) C⁻).

-: cutSp Mt M ([x] nil) nil.

-: cutSp Mt M ([x] ↑L (N x)) (↑L N')
  <- cutN Mt M ([x] N x) (N': conc (B⁺ , ·) C⁻).

-: cutSp Mt M ([x] &L₁ (Sp x)) (&L₁ Sp')
  <- cutSp Mt M ([x] Sp x) (Sp': lfoc B₁⁻ C⁻).

-: cutSp Mt M ([x] &L₂ (Sp x)) (&L₂ Sp')
  <- cutSp Mt M ([x] Sp x) (Sp': lfoc B₂⁻ C⁻).

-: cutSp Mt M ([x] ⊸L (V x) (Sp x)) (⊸L V' Sp')
  <- cutV Mt M ([x] V x) (V': rfoc B₁⁺)
  <- cutSp Mt M ([x] Sp x) (Sp': lfoc B₂⁻ C⁻).

%{ === Leftist substitution (left commutative cuts) === }%

-: left⁻ Mt (↑L M) N St (↑L N')
  <- left⁺ Mt M N St (N': conc (B⁺ , ·) C⁻).

-: left⁻ Mt (&L₁ Sp) N St (&L₁ Sp')
  <- left⁻ Mt Sp N St (Sp': lfoc B₁⁻ C⁻).

-: left⁻ Mt (&L₂ Sp) N St (&L₂ Sp')
  <- left⁻ Mt Sp N St (Sp': lfoc B₂⁻ C⁻).

-: left⁻ Mt (⊸L V Sp) N St (⊸L V Sp')
  <- left⁻ Mt Sp N St (Sp': lfoc B₂⁻ C⁻).

-: left⁺ Mt (foc X _ Sp) N St (foc X St Sp')
  <- left⁻ Mt Sp N St (Sp': lfoc B⁻ C⁻).

-: left⁺ Mt (↑R V) N St N'
  <- subst⁺ Mt V N (N': conc · C⁻).

-: left⁺ Mt (cL [y] M y) N St (cL [y] N' y)
  <- ({y: hyp⁺ Q⁺} left⁺ Mt (M y) N St (N' y: conc _Δ C⁻)).

-: left⁺ Mt (↓L [y] M y) N St (↓L [y] N' y)
  <- ({y: hyp⁻ B⁻} left⁺ Mt (M y) N St (N' y: conc _Δ C⁻)).

-: left⁺ Mt 0L N St 0L.

-: left⁺ Mt (⊕L M₁ M₂) N St (⊕L N₁' N₂')
  <- left⁺ Mt M₁ N St (N₁': conc (B₁⁺ , _Δ) C⁻)
  <- left⁺ Mt M₂ N St (N₂': conc (B₂⁺ , _Δ) C⁻).

-: left⁺ Mt (1L M) N St (1L N')
  <- left⁺ Mt M N St (N': conc _Δ C⁻).

-: left⁺ Mt (⊗L M) N St (⊗L N')
  <- left⁺ Mt M N St (N': conc (A⁺ , B⁺ , _Δ) C⁻).

%{ === Wrap-up === }%

%worlds (atom⁺ | atom⁻ | x⁺ | x⁻)
  (subst⁻ _ _ _ _ _)
  (subst⁺ _ _ _ _)
  (cutN _ _ _ _)
  (cutV _ _ _ _)
  (cutSp _ _ _ _)
  (left⁻ _ _ _ _ _)
  (left⁺ _ _ _ _ _).

%total 
  {(Mt1 Mt2 Mt3 Mt5 Mt6 Mt7 Mt8) 
    [(MN MV MSp MP VP SpL MiL) 
     (N V Sp SpP NiP NiL⁻ NiL⁺)]}
  (subst⁻ Mt5 MP  SpP _ _)
  (subst⁺ Mt6 VP  NiP _)
  (cutN   Mt1 MN  N _)
  (cutV   Mt2 MV  V _)
  (cutSp  Mt3 MSp Sp _)
  (left⁻  Mt7 SpL NiL⁻ _ _)
  (left⁺  Mt8 MiL NiL⁺ _ _).


%{ == Expansion == }%

eta⁻: {A⁻} ({γ: typ ⁻} stable γ -> lfoc A⁻ γ -> conc · γ) 
  -> conc · A⁻ 
  -> type.

eta⁺: {A⁺} (rfoc A⁺ -> conc _Δ C⁻)
  -> conc (A⁺ , _Δ) C⁻ 
  -> type.

%mode eta⁻ +A⁻ +Sp -N.
%mode eta⁺ +A⁺ +N -Ni.

-: eta⁺ (c Q⁺) ([v: rfoc (c Q⁺)] N v) (cL [x: hyp⁺ Q⁺] (N (cR x))).

-: eta⁻ (c Q⁻) ([γ][st][sp: lfoc (c Q⁻) γ] N γ st sp) (N (c Q⁻) aQ nil). 

-: eta⁺ (↓ A⁻) ([v: rfoc (↓ A⁻)] N v) (↓L [x: hyp⁻ A⁻] (N (↓R (N' x))))
  <- ({x: hyp⁻ A⁻} 
       eta⁻ A⁻ ([γ][st][sp: lfoc A⁻ γ] foc x st sp) 
         (N' x: conc · A⁻)).

-: eta⁻ (↑ A⁺) ([γ][st][sp: lfoc (↑ A⁺) γ] N γ st sp) (N (↑ A⁺) a↑ (↑L N'))
  <- eta⁺ A⁺ ([v: rfoc A⁺] ↑R v) (N': conc (A⁺ , ·) (↑ A⁺)).

-: eta⁺ 0 ([v: rfoc 0] N v) 0L.

-: eta⁺ (A⁺ ⊕ B⁺) ([v: rfoc (A⁺ ⊕ B⁺)] N v) (⊕L N₁ N₂)
  <- eta⁺ A⁺ ([v: rfoc A⁺] N (⊕R₁ v)) (N₁: conc (A⁺ , _Δ) C⁻)
  <- eta⁺ B⁺ ([v: rfoc B⁺] N (⊕R₂ v)) (N₂: conc (B⁺ , _Δ) C⁻).

-: eta⁺ 1 ([v: rfoc 1] N v) (1L (N 1R)).

-: eta⁺ (A⁺ ⊗ B⁺) ([v: rfoc (A⁺ ⊗ B⁺)] N v) (⊗L N₂)
  <- ({v₁: rfoc A⁺} 
       eta⁺ B⁺ ([v₂: rfoc B⁺] N (⊗R v₁ v₂)) (N₁ v₁: conc (B⁺ , _Δ) C⁻))
  <- eta⁺ A⁺ ([v₁: rfoc A⁺] N₁ v₁) (N₂: conc (A⁺ , B⁺ , _Δ) C⁻).

-: eta⁻ ⊤ ([γ][st][sp: lfoc ⊤ γ] N γ st sp) ⊤R.

-: eta⁻ (A⁻ & B⁻) ([γ][st][sp: lfoc (A⁻ & B⁻) γ] N γ st sp) (&R N₁ N₂)
  <- eta⁻ A⁻ ([γ][st][sp: lfoc A⁻ γ] N γ st (&L₁ sp)) (N₁: conc · A⁻)
  <- eta⁻ B⁻ ([γ][st][sp: lfoc B⁻ γ] N γ st (&L₂ sp)) (N₂: conc · B⁻).

-: eta⁻ (A⁺ ⊸ B⁻) ([γ][st][sp: lfoc (A⁺ ⊸ B⁻) γ] N γ st sp) (⊸R N₂)
  <- ({v: rfoc A⁺}
       eta⁻ B⁻ ([γ][st][sp: lfoc B⁻ γ] N γ st (⊸L v sp)) (N₁ v: conc · B⁻))
  <- eta⁺ A⁺ ([v: rfoc A⁺] N₁ v) (N₂: conc (A⁺ , ·) B⁻).

%worlds (vars | v | sp)
  (eta⁺ _ _ _)
  (eta⁻ _ _ _).
%total (A⁺ A⁻)
  (eta⁺ A⁺ _ _)
  (eta⁻ A⁻ _ _).


%{ == Unfocused admissibility == }%

%{ The key lemmas for establishing the completeness of the focused sequent
calculus are the "unfocused admissibility" lemmas, which establish that the 
normal rules of the sequent calculus are usable in the context of the focused
calculus. 

These lemmas are all provable by use of the cut and identity principles, though
the proofs are hardly straightfoward. The ``shift'' and ``unshift'' lemmas
simplify matters somewhat. }%

cut: conc · A⁻ -> (hyp⁻ A⁻ -> conc · C⁻) -> conc · C⁻ -> type.
%mode cut +D +E -F.

-: cut D E F <- inmet A⁻ Mt <- cutN (me Mt) D E F.

%worlds (vars) (cut _ _ _).
%total [] (cut _ _ _).

shift: conc · A⁻ -> conc · (↑ (↓ A⁻)) -> type.
%mode shift +D -E.

-: shift N (↑R (↓R N)).

%worlds (vars) (shift _ _).
%total [] (shift _ _).

unshift: conc · (↑ (↓ A⁻)) -> conc · A⁻ -> type.
%mode unshift +D -E.

-: unshift N M
  <- ({x: hyp⁻ (↑ (↓ A⁻))}
       eta⁻ A⁻
         ([γ][st][sp: lfoc A⁻ γ] foc x st (↑L (↓L [x] foc x st sp))) 
         (N' x: conc · A⁻))
  <- cut N ([x: hyp⁻ (↑ (↓ A⁻))] N' x) (M: conc · A⁻). 

%worlds (vars) (unshift _ _).
%total [] (unshift _ _).


%{ === Initial rules === }%

adm-init⁻: (hyp⁻ (c Q) -> conc · (c Q)) -> type.
%mode +{Q} -{N: hyp⁻ (c Q) -> conc · (c Q)} adm-init⁻ N.

-: adm-init⁻ ([x: hyp⁻ (c Q)] foc x aQ nil).

%worlds (vars) (adm-init⁻ _).
%total [] (adm-init⁻ _).

adm-init⁺: (hyp⁻ (↑ (c Q)) -> conc · (↑ (c Q))) -> type.
%mode +{Q} -{N: hyp⁻ (↑ (c Q)) -> conc · (↑ (c Q))} adm-init⁺ N.

-: adm-init⁺ ([x: hyp⁻ (↑ (c Q))] foc x a↑ (↑L (cL [x] ↑R (cR x)))).

%worlds (vars) (adm-init⁺ _).
%total [] (adm-init⁺ _).


%{ === Disjunction === }%

adm-falseL: hyp⁻ (↑ 0)
         -> conc · C⁻
         -> type.
%mode +{C⁻} +{X} -{N: conc · C⁻} adm-falseL X N.

-: adm-falseL (X: hyp⁻ (↑ 0)) N
  <- unshift (foc X a↑ (↑L 0L)) (N: conc · C⁻).

%worlds (vars) (adm-falseL _ _).
%total [] (adm-falseL _ _).

adm-orR₁: conc · (↑ A⁺)
       -> conc · (↑ (A⁺ ⊕ B⁺))
       -> type.
%mode +{A⁺} +{B⁺} +{N₁} -{N: conc · (↑ (A⁺ ⊕ B⁺))} adm-orR₁ N₁ N.

-: adm-orR₁ (N₁: conc · (↑ A⁺)) N
  <- eta⁺ A⁺ ([v: rfoc A⁺] ↑R (⊕R₁ v)) 
       (NId₁: conc (A⁺ , ·) (↑ (A⁺ ⊕ B⁺)))
  <- cut N₁ ([x: hyp⁻ (↑ A⁺)] foc x a↑ (↑L NId₁))
       (N: conc · (↑ (A⁺ ⊕ B⁺))).

%worlds (vars) (adm-orR₁ _ _).
%total [] (adm-orR₁ _ _).

adm-orR₂: conc · (↑ B⁺)
       -> conc · (↑ (A⁺ ⊕ B⁺))
       -> type.
%mode +{A⁺} +{B⁺} +{N₂} -{N: conc · (↑ (A⁺ ⊕ B⁺))} adm-orR₂ N₂ N.

-: adm-orR₂ (N₂: conc · (↑ B⁺)) N
  <- eta⁺ B⁺ ([v: rfoc B⁺] ↑R (⊕R₂ v)) 
       (NId₂: conc (B⁺ , ·) (↑ (A⁺ ⊕ B⁺)))
  <- cut N₂ ([x: hyp⁻ (↑ B⁺)] foc x a↑ (↑L NId₂))
       (N: conc · (↑ (A⁺ ⊕ B⁺))).

%worlds (vars) (adm-orR₂ _ _).
%total [] (adm-orR₂ _ _).

adm-orL: (hyp⁻ (↑ A⁺) -> conc · C⁻)
      -> (hyp⁻ (↑ B⁺) -> conc · C⁻)
      -> (hyp⁻ (↑ (A⁺ ⊕ B⁺)) -> conc · C⁻)
      -> type.
%mode adm-orL +N₁ +N₂ -N.

-: adm-orL (N₁: hyp⁻ (↑ A⁺) -> conc · C⁻) (N₂: hyp⁻ (↑ B⁺) -> conc · C⁻) N
  <- ({x₁: hyp⁻ (↑ A⁺)} shift (N₁ x₁) (NShift₁ x₁: conc · (↑ (↓ C⁻))))
  <- ({x₂: hyp⁻ (↑ B⁺)} shift (N₂ x₂) (NShift₂ x₂: conc · (↑ (↓ C⁻))))
  <- eta⁺ A⁺ 
       ([v: rfoc A⁺] ↑R (⊕R₁ (↓R (↑R v))))
       (NId₁: conc (A⁺ , ·) (↑ (↓ (↑ A⁺) ⊕ ↓ (↑ B⁺))))
  <- eta⁺ B⁺ 
       ([v: rfoc B⁺] ↑R (⊕R₂ (↓R (↑R v))))
       (NId₂: conc (B⁺ , ·) (↑ (↓ (↑ A⁺) ⊕ ↓ (↑ B⁺))))
  <- ({x: hyp⁻ (↑ (A⁺ ⊕ B⁺))}
       cut (foc x a↑ (↑L (⊕L NId₁ NId₂)))
         ([x: hyp⁻ (↑ (↓ (↑ A⁺) ⊕ ↓ (↑ B⁺)))]  
           foc x a↑ (↑L (⊕L (↓L NShift₁) (↓L NShift₂))))
         (NShift x: conc · (↑ (↓ C⁻))))
  <- ({x: hyp⁻ (↑ (A⁺ ⊕ B⁺))}
       unshift (NShift x) (N x: conc · C⁻)).

%worlds (vars) (adm-orL _ _ _).
%total [] (adm-orL _ _ _).
    

%{ === Positive conjunction === }%

adm-oneR: conc · (↑ 1) -> type.
%mode adm-oneR -F.

-: adm-oneR (↑R 1R).

%worlds (vars) (adm-oneR _).
%total [] (adm-oneR _).

adm-oneL: conc · C⁻
       -> (hyp⁻ (↑ 1) -> conc · C⁻)
       -> type.
%mode adm-oneL +N₁ -N.

-: adm-oneL N₁ N 
  <- shift N₁ (NShift: conc · (↑ (↓ C⁻)))
  <- ({x: hyp⁻ (↑ 1)}
       unshift (foc x a↑ (↑L (1L NShift))) (N x: conc · C⁻)).

%worlds (vars) (adm-oneL _ _).
%total [] (adm-oneL _ _).

adm-and⁺R: conc · (↑ A⁺) 
        -> conc · (↑ B⁺) 
        -> conc · (↑ (A⁺ ⊗ B⁺))
        -> type.
%mode adm-and⁺R +N₁ +N₂ -N.

-: adm-and⁺R (N₁: conc · (↑ A⁺)) (N₂: conc · (↑ B⁺)) N
  <- ({v₁: rfoc A⁺}
       eta⁺ B⁺ ([v₂: rfoc B⁺] (↑R (⊗R v₁ v₂))) 
         (NIdA v₁: conc (B⁺ , ·) (↑ (A⁺ ⊗ B⁺))))
  <- ({x₂: hyp⁻ (↑ B⁺)}
       eta⁺ A⁺ ([v₁: rfoc A⁺] foc x₂ a↑ (↑L (NIdA v₁))) 
         (NId x₂: conc (A⁺ , ·) (↑ (A⁺ ⊗ B⁺))))
  <- ({x₂: hyp⁻ (↑ B⁺)}
       cut N₁ ([x₁: hyp⁻ (↑ A⁺)] foc x₁ a↑ (↑L (NId x₂))) 
         (NB x₂: conc · (↑ (A⁺ ⊗ B⁺))))
  <- cut N₂ ([x₂: hyp⁻ (↑ B⁺)] NB x₂)
       (N: conc · (↑ (A⁺ ⊗ B⁺))).

%worlds (vars) (adm-and⁺R _ _ _).
%total [] (adm-and⁺R _ _ _).

adm-and⁺L: (hyp⁻ (↑ A⁺) -> hyp⁻ (↑ B⁺) -> conc · C⁻) 
        -> (hyp⁻ (↑ (A⁺ ⊗ B⁺)) -> conc · C⁻)
        -> type.
%mode adm-and⁺L +N₁ -N.

-: adm-and⁺L (N₁: hyp⁻ (↑ A⁺) -> hyp⁻ (↑ B⁺) -> conc · C⁻) N
  <- ({x₁: hyp⁻ (↑ A⁺)}{x₂: hyp⁻ (↑ B⁺)}
       shift (N₁ x₁ x₂) (NShift₁ x₁ x₂: conc · (↑ (↓ C⁻))))
  <- ({v₁: rfoc A⁺}
       eta⁺ B⁺ ([v₂: rfoc B⁺] ↑R (⊗R (↓R (↑R v₁)) (↓R (↑R v₂))))
         (NIdA v₁: conc (B⁺ , ·) (↑ (↓ (↑ A⁺) ⊗ ↓ (↑ B⁺)))))
  <- eta⁺ A⁺ ([v₁: rfoc A⁺] NIdA v₁)
       (NId: conc (A⁺ , B⁺ , ·) (↑ (↓ (↑ A⁺) ⊗ ↓ (↑ B⁺))))
  <- ({x: hyp⁻ (↑ (A⁺ ⊗ B⁺))}
       cut (foc x a↑ (↑L (⊗L NId)))
         ([x: hyp⁻ (↑ (↓ (↑ A⁺) ⊗ ↓ (↑ B⁺)))]
           foc x a↑ (↑L (⊗L (↓L [x₁] ↓L [x₂] NShift₁ x₁ x₂))))
         (NShift x: conc · (↑ (↓ C⁻))))
  <- ({x: hyp⁻ (↑ (A⁺ ⊗ B⁺))}
       unshift (NShift x) (N x: conc · C⁻)).

%worlds (vars) (adm-and⁺L _ _).
%total [] (adm-and⁺L _ _).


%{ === Negative conjunction === }%

adm-topR: conc · ⊤ -> type.
%mode adm-topR -F.

-: adm-topR ⊤R.

%worlds (vars) (adm-topR _).
%total [] (adm-topR _).

adm-and⁻R: conc · A⁻
        -> conc · B⁻
        -> conc · (A⁻ & B⁻)
        -> type.
%mode adm-and⁻R +N₁ +N₂ -N.

-: adm-and⁻R N₁ N₂ (&R N₁ N₂).

%worlds (vars) (adm-and⁻R _ _ _).
%total [] (adm-and⁻R _ _ _).

adm-and⁻L₁: (hyp⁻ A⁻ -> conc · C⁻)
         -> (hyp⁻ (A⁻ & B⁻) -> conc · C⁻)
         -> type.
%mode +{A⁻} +{B⁻} +{C⁻} +{N₁} -{N: hyp⁻ (A⁻ & B⁻) -> conc · C⁻} 
  adm-and⁻L₁ N₁ N.

-: adm-and⁻L₁ (N₁: hyp⁻ A⁻ -> conc · C⁻) N
  <- ({x₁: hyp⁻ A⁻} shift (N₁ x₁) (NShift₁ x₁: conc · (↑ (↓ C⁻))))
  <- ({x: hyp⁻ (A⁻ & B⁻)}
       eta⁻ A⁻ ([γ][st][sp: lfoc A⁻ γ] foc x st (&L₁ sp))  
         (NId₁ x: conc · A⁻))
  <- ({x: hyp⁻ (A⁻ & B⁻)}
       eta⁻ B⁻ ([γ][st][sp: lfoc B⁻ γ] foc x st (&L₂ sp)) 
         (NId₂ x: conc · B⁻))
  <- ({x: hyp⁻ (A⁻ & B⁻)}
       cut (&R (↑R (↓R (NId₁ x))) (↑R (↓R (NId₂ x)))) 
         ([x: hyp⁻ (↑ (↓ A⁻) & ↑ (↓ B⁻))]
           foc x a↑ (&L₁ (↑L (↓L [x₁: hyp⁻ A⁻] NShift₁ x₁))))
         (NShift x: conc · (↑ (↓ C⁻))))
  <- ({x: hyp⁻ (A⁻ & B⁻)}
       unshift (NShift x) (N x: conc · C⁻)).  

%worlds (vars) (adm-and⁻L₁ _ _).
%total [] (adm-and⁻L₁ _ _).

adm-and⁻L₂: (hyp⁻ B⁻ -> conc · C⁻)
         -> (hyp⁻ (A⁻ & B⁻) -> conc · C⁻)
         -> type.
%mode +{A⁻} +{B⁻} +{C⁻} +{N₁} -{N: hyp⁻ (A⁻ & B⁻) -> conc · C⁻} 
  adm-and⁻L₂ N₁ N.

-: adm-and⁻L₂ (N₂: hyp⁻ B⁻ -> conc · C⁻) N
  <- ({x₂: hyp⁻ B⁻} shift (N₂ x₂) (NShift₂ x₂: conc · (↑ (↓ C⁻))))
  <- ({x: hyp⁻ (A⁻ & B⁻)}
       eta⁻ A⁻ ([γ][st][sp: lfoc A⁻ γ] foc x st (&L₁ sp))  
         (NId₁ x: conc · A⁻))
  <- ({x: hyp⁻ (A⁻ & B⁻)}
       eta⁻ B⁻ ([γ][st][sp: lfoc B⁻ γ] foc x st (&L₂ sp)) 
         (NId₂ x: conc · B⁻))
  <- ({x: hyp⁻ (A⁻ & B⁻)}
       cut (&R (↑R (↓R (NId₁ x))) (↑R (↓R (NId₂ x)))) 
         ([x: hyp⁻ (↑ (↓ A⁻) & ↑ (↓ B⁻))]
           foc x a↑ (&L₂ (↑L (↓L [x₂: hyp⁻ B⁻] NShift₂ x₂))))
         (NShift x: conc · (↑ (↓ C⁻))))
  <- ({x: hyp⁻ (A⁻ & B⁻)}
       unshift (NShift x) (N x: conc · C⁻)).  

%worlds (vars) (adm-and⁻L₂ _ _).
%total [] (adm-and⁻L₂ _ _).


%{ === Implication === }%

adm-impR: (hyp⁻ (↑ A⁺) -> conc · B⁻)
       -> conc · (A⁺ ⊸ B⁻)
       -> type.
%mode adm-impR +N₁ -N.

-: adm-impR (N₁: hyp⁻ (↑ A⁺) -> conc · B⁻) N
  <- ({x: hyp⁻ (↓ (↑ A⁺) ⊸ B⁻)}{v: rfoc A⁺}
       eta⁻ B⁻
         ([γ][st][sp: lfoc B⁻ γ] 
           foc x st (⊸L (↓R (↑R v)) sp))
         (NId₁ x v: conc · B⁻))
  <- ({x: hyp⁻ (↓ (↑ A⁺) ⊸ B⁻)}
       eta⁺ A⁺
         ([v: rfoc A⁺] NId₁ x v)
         (NId x: conc (A⁺ , ·) B⁻))
  <- cut (⊸R (↓L [x₁: hyp⁻ (↑ A⁺)] N₁ x₁))
       ([x: hyp⁻ (↓ (↑ A⁺) ⊸ B⁻)] ⊸R (NId x))
       N.

%worlds (vars) (adm-impR _ _).
%total [] (adm-impR _ _).

adm-impL: conc · (↑ A⁺)
       -> (hyp⁻ B⁻ -> conc · C⁻)
       -> (hyp⁻ (A⁺ ⊸ B⁻) -> conc · C⁻)
       -> type.
%mode adm-impL +N₁ +N₂ -N.

-: adm-impL (N₁: conc · (↑ A⁺)) (N₂: hyp⁻ B⁻ -> conc · C⁻) N
  <- ({x₂: hyp⁻ B⁻} shift (N₂ x₂) (NShift₂ x₂: conc · (↑ (↓ C⁻)))) 
  <- ({x: hyp⁻ (A⁺ ⊸ B⁻)} {v: rfoc A⁺}
       eta⁻ B⁻
         ([γ][st][sp: lfoc B⁻ γ] foc x st (⊸L v sp))
         (NId₁ x v: conc · B⁻))
  <- ({x: hyp⁻ (A⁺ ⊸ B⁻)}
       eta⁺ A⁺ ([v: rfoc A⁺] ↑R (↓R (NId₁ x v)))
         (NId₂ x: conc (A⁺ , ·) (↑ (↓ B⁻))))
  <- ({x: hyp⁻ (A⁺ ⊸ B⁻)}
       cut (⊸R (↓L [x₁: hyp⁻ (↑ A⁺)] foc x₁ a↑ (↑L (NId₂ x))))
         ([x: hyp⁻ (↓ (↑ A⁺) ⊸ ↑ (↓ B⁻))]
           foc x a↑ (⊸L (↓R N₁) (↑L (↓L [x₂: hyp⁻ B⁻] NShift₂ x₂))))
         (NShift x: conc · (↑ (↓ C⁻))))
  <- ({x: hyp⁻ (A⁺ ⊸ B⁻)}
       unshift (NShift x) (N x: conc · C⁻)).

%worlds (vars) (adm-impL _ _ _).
%total [] (adm-impL _ _ _).


%{ == Unfocused system == }%

%{ === Syntax === }%

prop: type. %name prop P.
a: atom P -> prop.
false: prop.
or: prop -> prop -> prop. 
true: prop.
and: prop -> prop -> prop.
imp: prop -> prop -> prop.

props: type. %name props _Ψ.
○: props.
;: prop -> props -> props. %infix right 3 ;.

%{ The judgment ``t P A'' relates unpolarized propositions ``P'' and polarized
propositions ``A''. The judgment can be effectively run as an erasure function
from polarized to unpolarized propositions. }%

t: typ P -> prop -> type. %name t Trans.
%mode t +A -P.

tc: t (c Q) (a Q).
t↑: t A⁺ P -> t (↑ A⁺) P. 
t↓: t A⁻ P -> t (↓ A⁻) P.
t0: t 0 false.
t⊕: t A⁺ P₁ -> t B⁺ P₂ -> t (A⁺ ⊕ B⁺) (or P₁ P₂).
t1: t 1 true.
t⊗: t A⁺ P₁ -> t B⁺ P₂ -> t (A⁺ ⊗ B⁺) (and P₁ P₂).
t⊤: t ⊤ true.
t&: t A⁻ P₁ -> t B⁻ P₂ -> t (A⁻ & B⁻) (and P₁ P₂).
t⊸: t A⁺ P₁ -> t B⁻ P₂ -> t (A⁺ ⊸ B⁻) (imp P₁ P₂).

%worlds (vars) (t _ _).
%total A (t A _).

tΔ: pos -> props -> type. %name tΔ TransΔ.
t·: tΔ · ○.
t,: t A⁺ P -> tΔ _Δ _Ψ -> tΔ (A⁺ , _Δ) (P ; _Ψ).
  

%{ === Sequent rules === }%

left: prop -> type. %name left H. 
right': props -> prop -> type. %name right' D.
%abbrev right = right' ○.
%block h: some {P} block {h: left P}.

init: left (a Q) -> right (a Q).

falseL: left false -> right P.

orR₁: right P₁ -> right (or P₁ P₂).

orR₂: right P₂ -> right (or P₁ P₂).

orL: (left P₁ -> right Q) 
     -> (left P₂ -> right Q)
     -> (left (or P₁ P₂) -> right Q).

trueR: right true.

andR: right P₁ -> right P₂ -> right (and P₁ P₂).

andL: (left P₁ -> left P₂ -> right Q)
       -> (left (and P₁ P₂) -> right Q).

impR: (left P₁ -> right P₂)
      -> right (imp P₁ P₂).

impL: right P₁
      -> (left P₂ -> right Q)
      -> (left (imp P₁ P₂) -> right Q).

': (left P -> right' _Ψ Q) -> right' (P ; _Ψ) Q.

id: right P -> right P -> type.
refl: id D D.


%{ === Soundness === }%

%{ Soundness is established in a context where each polarized 
hypothesis is mapped to its erasure. }%

soundhyp⁺: hyp⁺ Q⁺ -> left (a Q⁺) -> type.
%block sound⁺: some {Q⁺}
  block {x⁺: hyp⁺ Q⁺}{h: left (a Q⁺)}{_: soundhyp⁺ x⁺ h}.

soundhyp⁻: hyp⁻ A⁻ -> t A⁻ P -> left P -> type.
%block sound⁻: some {A⁻}{P}{T: t A⁻ P} 
  block {x⁻: hyp⁻ A⁻}{h: left P}{_: soundhyp⁻ x⁻ T h}.

%block sound = (atom⁺ | atom⁻ | sound⁺ | sound⁻).

%mode soundhyp⁺ +X⁺ -H.
%worlds (sound) (soundhyp⁺ _ _).
%total [] (soundhyp⁺ _ _).

%mode soundhyp⁻ +X⁻ -T -H.
%worlds (sound) (soundhyp⁻ _ _ _).
%total [] (soundhyp⁻ _ _ _).

%{ The three mutually inductive theorems deal with the three classes of
syntax. }%

soundV: rfoc A⁺ -> t A⁺ P -> right P -> type.
soundN: conc _Δ A⁻ -> tΔ _Δ _Ψ -> t A⁻ P -> right' _Ψ P -> type. 
soundSp: lfoc A⁻ C⁻ -> t A⁻ P -> t C⁻ Q -> (left P -> right Q) -> type.

%mode soundV +V +T -D.
%mode soundN +N +TΔ +T -D.
%mode soundSp +Sp +T₁ +T₂ -D.

-: soundV (cR X) tc (init H)
  <- soundhyp⁺ X H.

-: soundV (↓R N) (t↓ T) D
  <- soundN N t· T D.

-: soundV (⊕R₁ V) (t⊕ T₁ _) (orR₁ D)
  <- soundV V T₁ D.

-: soundV (⊕R₂ V) (t⊕ _ T₂) (orR₂ D)
  <- soundV V T₂ D.

-: soundV 1R t1 trueR.

-: soundV (⊗R V₁ V₂) (t⊗ T₁ T₂) (andR D₁ D₂)
  <- soundV V₁ T₁ D₁
  <- soundV V₂ T₂ D₂.

-: soundN (foc X _ Sp) t· (TCQ: t C⁻ Q) (D H)
  <- soundhyp⁻ X (TAP: t A⁻ P) (H: left P)
  <- soundSp Sp TAP TCQ (D: left P -> right Q).

-: soundN (↑R V) t· (t↑ T) D
  <- soundV V T D.

-: soundN ⊤R t· t⊤ trueR.

-: soundN (&R N₁ N₂) t· (t& T₁ T₂) (andR D₁ D₂)
  <- soundN N₁ t· T₁ D₁
  <- soundN N₂ t· T₂ D₂.

-: soundN (⊸R N) t· (t⊸ T₁ T₂) (impR D)
  <- soundN N (t, T₁ t·) T₂ (' (D: left P₁ -> right P₂)).

-: soundN (cL [x: hyp⁺ Q⁺] N x) (t, tc TΔ) TCQ (' D)
  <- ({x: hyp⁺ Q⁺}{h: left (a Q⁺)} 
       soundhyp⁺ x h ->
         soundN (N x) TΔ TCQ (D h: right' _Ψ Q)).

-: soundN (↓L [x: hyp⁻ A⁻] N x) (t, (t↓ T) TΔ) TCQ (' D)
  <- ({x: hyp⁻ A⁻}{h: left P}
       soundhyp⁻ x T h ->
         soundN (N x) TΔ TCQ (D h: right' _Ψ Q)).

sound-falseL: {_Ψ} left false 
           -> right' _Ψ Q -> type.
-: sound-falseL _ H (falseL H).
-: sound-falseL _ H (' D) 
  <- {h} sound-falseL _ H (D h).
%mode +{_Ψ} +{Q} +{H: left false} -{D: right' _Ψ Q} sound-falseL _Ψ H D.
%worlds (atom⁺ | atom⁻ | h) (sound-falseL _ _ _). 
%total _Ψ (sound-falseL _Ψ _ _).

-: soundN 0L TΔ TCQ (' D)
  <- ({h: left false} sound-falseL _ h (D h)).

sound-orL: left (or P₁ P₂)
        -> (left P₁ -> right' _Ψ Q)
        -> (left P₂ -> right' _Ψ Q)
        -> right' _Ψ Q -> type.
-: sound-orL H D₁ D₂ (orL D₁ D₂ H).
-: sound-orL H ([h₁] ' (D₁ h₁)) ([h₂] ' (D₂ h₂)) (' D) 
  <- {h} sound-orL H ([h₁] D₁ h₁ h) ([h₂] D₂ h₂ h) (D h).
%mode sound-orL +H +D₁ +D₂ -D.
%worlds (atom⁺ | atom⁻ | h) (sound-orL _ _ _ _). 
%total D₁ (sound-orL _ D₁ _ _).

-: soundN (⊕L N₁ N₂) (t, (t⊕ T₁ T₂) TΔ) TCQ (' D)
  <- soundN N₁ (t, T₁ TΔ) TCQ (' (D₁: left P₁ -> right' _Ψ Q))
  <- soundN N₂ (t, T₂ TΔ) TCQ (' (D₂: left P₂ -> right' _Ψ Q))
  <- ({h: left (or P₁ P₂)} sound-orL h D₁ D₂ (D h)).

-: soundN (1L N) (t, t1 TΔ) TCQ (' [h: left true] D)
  <- soundN N TΔ TCQ (D: right' _Ψ Q).

sound-andL: left (and P₁ P₂)
         -> (left P₁ -> left P₂ -> right' _Ψ Q)
         -> right' _Ψ Q -> type.
-: sound-andL H D₁ (andL D₁ H).
-: sound-andL H ([h₁] [h₂] ' (D₁ h₁ h₂)) (' D) 
  <- {h} sound-andL H ([h₁] [h₂] D₁ h₁ h₂ h) (D h).
%mode sound-andL +H +D₁ -D.
%worlds (atom⁺ | atom⁻ | h) (sound-andL _ _ _).
%total D₁ (sound-andL _ D₁ _).

-: soundN (⊗L N) (t, (t⊗ T₁ T₂) TΔ) TCQ (' D)
  <- soundN N (t, T₁ (t, T₂ TΔ)) TCQ (' [h₁] ' [h₂] D₁ h₁ h₂)
  <- ({h: left (and P₁ P₂)} sound-andL h D₁ (D h: right' _Ψ Q)).

-: soundSp nil tc tc ([h] init h).

-: soundSp (↑L N) (t↑ T₁) TCQ D
  <- soundN N (t, T₁ t·) TCQ (' (D: left P -> right Q)).

-: soundSp (&L₁ Sp) (t& T₁ T₂) TCQ (andL ([h₁: left P₁][_] D h₁))
  <- soundSp Sp T₁ TCQ (D: left P₁ -> right Q).

-: soundSp (&L₂ Sp) (t& T₁ T₂) TCQ (andL ([_][h₂: left P₂] D h₂))
  <- soundSp Sp T₂ TCQ (D: left P₂ -> right Q).

-: soundSp (⊸L V Sp) (t⊸ T₁ T₂) TCQ (impL D₁ ([h₂: left P₂] D₂ h₂))
  <- soundV V T₁ (D₁: right P₁)
  <- soundSp Sp T₂ TCQ (D₂: left P₂ -> right Q).

%worlds (atom⁺ | atom⁻ | sound⁺ | sound⁻)
  (soundV _ _ _)
  (soundN _ _ _ _)
  (soundSp _ _ _ _).
%total (V N Sp) 
  (soundV V _ _)
  (soundN N _ _ _)
  (soundSp Sp _ _ _).


%{ === Completeness === }%

%{ Most of the complexity of this proof comes from the most boring part: the
ability to tolerate arbitray nestings of shifts. This lemma helps in dealing
with those: }%

shiftable: (hyp⁻ A⁻ -> conc · C⁻) -> (hyp⁻ (↑ (↓ A⁻)) -> conc · C⁻) -> type.
-: shiftable N M
  <- ({x: hyp⁻ A⁻} shift (N x) (NShift x))
  <- ({x: hyp⁻ (↑ (↓ A⁻))} unshift (foc x a↑ (↑L (↓L NShift)))
       (M x: conc · C⁻)).
%mode shiftable +N -M.
%worlds (vars) (shiftable _ _).
%total [] (shiftable _ _).

%{ Completeness is established in a context where each erased 
hypothesis is mapped to some polarization. This is the same, type-wise, as
the context for soundness, but the computational interpretation runs the
opposite way 'round.

This version is less than ideal in the specific sense that it only allows
generic propositions to be related to negative propositions; doing things
properly would require blocks to be able to be disjunctive, I think. }%

small: type. 
big: type.
s: small.
b: small -> big.

completehyp: left P -> t A⁻ P -> hyp⁻ A⁻ -> type.
%block complete⁻: some {A⁻}{P}{T: t A⁻ P} 
  block {x⁻: hyp⁻ A⁻}{h: left P}{_: completehyp h T x⁻}.

%mode completehyp +H -T -X⁻.
%worlds (atom⁺ | atom⁻ | complete⁻) (completehyp _ _ _).
%total [] (completehyp _ _ _).

complete: big -> right P -> t A⁻ P -> conc · A⁻ -> type.
%mode complete +S +D +T -N.

-: complete S D (t↑ (t↓ T)) (↑R (↓R N))
  <- complete S D T N.

cinit: t (A⁻: typ ⁻) (a Q)
    -> t (B⁻: typ ⁻) (a Q)
    -> (hyp⁻ B⁻ -> conc · A⁻)
    -> type.
-: cinit tc tc N
  <- adm-init⁻ (N: hyp⁻ (c Q) -> conc · (c Q)).
-: cinit (t↑ tc) (t↑ tc) N
  <- adm-init⁺ (N: hyp⁻ (↑ (c Q)) -> conc · (↑ (c Q))).
-: cinit (t↑ (t↓ T)) TH ([x] ↑R (↓R (N x)))
  <- cinit T TH (N: hyp⁻ B⁻ ->  conc · A⁻).
-: cinit T (t↑ (t↓ TH)) M
  <- cinit T TH (N: hyp⁻ B⁻ -> conc · A⁻)
  <- shiftable N M.
%mode cinit +T +TH -N.
%worlds (vars) (cinit _ _ _).
%total [T TH] (cinit T TH _).

-: complete S (init H) (T: t A⁻ (a Q)) (D X)
  <- completehyp H (TH: t B⁻ (a Q)) (X: hyp⁻ B⁻)
  <- cinit T TH (D: hyp⁻ B⁻ -> conc · A⁻).

cfalseL: t A⁻ false
      -> (hyp⁻ A⁻ -> conc · C⁻)
      -> type.
-: cfalseL (t↑ t0) N 
  <- ({x} adm-falseL x (N x)).
-: cfalseL (t↑ (t↓ (t↑ TH))) M
  <- cfalseL (t↑ TH) N
  <- shiftable N M.
%mode +{A⁻} +{C⁻} +{T: t A⁻ false} -{N: hyp⁻ A⁻ -> conc · C⁻} cfalseL T N.
%worlds (vars) (cfalseL _ _).
%total T (cfalseL T _).

-: complete S (falseL H) T (D X)
  <- completehyp H (TH: t B⁻ false) (X: hyp⁻ B⁻)
  <- cfalseL TH (D: hyp⁻ B⁻ -> conc · C⁻).

-: complete S (orR₁ D) (t↑ (t⊕ T₁ T₂)) N
  <- complete S D (t↑ T₁) (N₁: conc · (↑ A⁺))
  <- adm-orR₁ N₁ (N: conc · (↑ (A⁺ ⊕ B⁺))).

-: complete S (orR₂ D) (t↑ (t⊕ T₁ T₂)) N
  <- complete S D (t↑ T₂) (N₂: conc · (↑ B⁺))
  <- adm-orR₂ N₂ (N: conc · (↑ (A⁺ ⊕ B⁺))).

corL: small
   -> t A⁻ (or P₁ P₂)
   -> {D: right Q} id D (orL D₁ D₂ (H: left (or P₁ P₂)))
   -> t C⁻ Q
   -> (hyp⁻ A⁻ -> conc · C⁻)
   -> type.        
%mode corL +S +TH +D +Id +T -N.
-: corL S (t↑ (t⊕ T₁ T₂)) (orL D₁ D₂ H) refl T N
  <- ({x₁: hyp⁻ (↑ A⁺)} {h₁: left P₁} 
       completehyp h₁ (t↑ T₁) x₁ ->
         complete (b s) (D₁ h₁) T (N₁ x₁: conc · C⁻))
  <- ({x₂: hyp⁻ (↑ B⁺)} {h₂: left P₂} 
       completehyp h₂ (t↑ T₂) x₂ ->
         complete (b s) (D₂ h₂) T (N₂ x₂: conc · C⁻))
  <- adm-orL N₁ N₂ (N: hyp⁻ (↑ (A⁺ ⊕ B⁺)) -> conc · C⁻).
-: corL S (t↑ (t↓ (t↑ TH))) D Id T M
  <- corL S (t↑ TH) D Id T N
  <- shiftable N M.

-: complete (b S) (orL D₁ D₂ H) T (N X)
  <- completehyp H TH X
  <- corL S TH (orL D₁ D₂ H) refl T (N: hyp⁻ A⁻ -> conc · C⁻).

-: complete S trueR t⊤ N
  <- adm-topR (N: conc · ⊤).

-: complete S trueR (t↑ t1) N
  <- adm-oneR (N: conc · (↑ 1)).

-: complete S (andR D₁ D₂) (t↑ (t⊗ T₁ T₂)) N
  <- complete S D₁ (t↑ T₁) (N₁: conc · (↑ A⁺))
  <- complete S D₂ (t↑ T₂) (N₂: conc · (↑ B⁺))
  <- adm-and⁺R N₁ N₂ (N: conc · (↑ (A⁺ ⊗ B⁺))).

-: complete S (andR D₁ D₂) (t& T₁ T₂) N
  <- complete S D₁ T₁ (N₁: conc · A⁻)
  <- complete S D₂ T₂ (N₂: conc · B⁻)
  <- adm-and⁻R N₁ N₂ (N: conc · (A⁻ & B⁻)).

candL: small
    -> t A⁻ (and P₁ P₂)
    -> {D: right Q} id D (andL D₁ (H: left (and P₁ P₂)))
    -> t C⁻ Q
    -> (hyp⁻ A⁻ -> conc · C⁻)
    -> type. 
%mode candL +S +TH +D +Id +T -N.
-: candL S (t↑ (t⊗ (T₁: t A⁺ P₁) (T₂: t B⁺ P₂))) 
     (andL (D₁: left P₁ -> left P₂ -> right' ○ Q) (H: left (and P₁ P₂)))
     refl (T: t C⁻ Q) (N: hyp⁻ (↑ (A⁺ ⊗ B⁺)) -> conc · C⁻)
  <- ({x₁: hyp⁻ (↑ A⁺)}{h₁: left P₁} completehyp h₁ (t↑ T₁) x₁ ->
      {x₂: hyp⁻ (↑ B⁺)}{h₂: left P₂} completehyp h₂ (t↑ T₂) x₂ ->
        complete (b s) (D₁ h₁ h₂) T (N₁ x₁ x₂: conc · C⁻))
  <- adm-and⁺L N₁ N. 
-: candL S (t& T₁ T₂) (andL D₁ H) refl T ([x] N x x) %% Contraction
  <- ({x₁: hyp⁻ A⁻}{h₁: left P₁} completehyp h₁ T₁ x₁ ->
      {x₂: hyp⁻ B⁻}{h₂: left P₂} completehyp h₂ T₂ x₂ ->
        complete (b s) (D₁ h₁ h₂) T (N₁ x₁ x₂: conc · C⁻))
  <- ({x₁} adm-and⁻L₂ (N₁ x₁) ([x] N₂ x x₁))
  <- ({x} adm-and⁻L₁ (N₂ x) (N x)). 
-: candL S (t↑ (t↓ TH)) D Id T M
  <- candL S TH D Id T N
  <- shiftable N M.

-: complete (b S) (andL D₁ H) T (N X)
  <- completehyp H TH X
  <- candL S TH (andL D₁ H) refl T N.

-: complete S (impR D) (t⊸ T₁ T₂) M
  <- ({x: hyp⁻ (↑ A⁺)}{h: left P₁} 
       completehyp h (t↑ T₁) x ->
         complete S (D h) T₂ (N x))
  <- adm-impR N M.

cimpL: small
    -> t A⁻ (imp P₁ P₂)
    -> {D: right Q} id D (impL D₁ D₂ (H: left (imp P₁ P₂)))
    -> t C⁻ Q
    -> (hyp⁻ A⁻ -> conc · C⁻)
    -> type.
%mode cimpL +S +TH +D +Id +T -N.
-: cimpL S (t⊸ T₁ T₂) (impL D₁ D₂ H) refl T N
  <- complete (b s) D₁ (t↑ T₁) (N₁: conc · (↑ A⁺))
  <- ({x₂: hyp⁻ B⁻}{h₂: left P₂} 
       completehyp h₂ T₂ x₂ ->
         complete (b s) (D₂ h₂) T (N₂ x₂: conc · C⁻))
  <- adm-impL N₁ N₂ (N: hyp⁻ (A⁺ ⊸ B⁻) -> conc · C⁻).
-: cimpL S (t↑ (t↓ TH)) D Id T M
  <- cimpL S TH D Id T N
  <- shiftable N M.

-: complete (b S) (impL D₁ D₂ H) T (N X)
  <- completehyp H TH X
  <- cimpL S TH (impL D₁ D₂ H) refl T N.

%worlds (atom⁺ | atom⁻ | complete⁻) 
  (corL _ _ _ _ _ _)
  (candL _ _ _ _ _ _)
  (cimpL _ _ _ _ _ _)
  (complete _ _ _ _).
%total {(D DorL DandL DimpL) (S SorL SandL SimpL) (T TorL TandL TimpL)}
  (corL SorL TorL DorL _ _ _)
  (candL SandL TandL DandL _ _ _)
  (cimpL SimpL TimpL DimpL _ _ _)
  (complete S D T _).
